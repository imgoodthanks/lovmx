defmodule NoFlo.Network.Test do
  use ExUnit.Case

  # Holo protocol
  ## http://noflojs.org/documentation/protocol/
  
  # Protocol for starting and stopping FBP networks, and finding out about their state.


  # test "Bridge.start",
  # do: assert Bridge.start %Data{}

  # # start
#   #
#   # Start execution of a FBP network based on a given graph.
#   #
#   # graph: graph the action targets
#   # secret: access token to authorize the user
#
#
#   test "Tube.getstatus",
#   do: assert Tube.getstatus %Data{}
#
#   # getstatus
#   #
#   # Get the current status of the runtime. The runtime should respond with a status message.
#   #
#   # graph: graph the action targets
#   # secret: access token to authorize the user
#
#
#
#
#   test "Bridge.stop",
#   do: assert Bridge.stop %Data{}
#
#   # stop
#   #
#   # Stop execution of a FBP network based on a given graph.
#   #
#   # graph: graph the action targets
#   # secret: access token to authorize the user
#
#
#
#   test "Bridge.persist",
#   do: assert Bridge.persist %Data{}
#
#   # persist
#   #
#   # Tells the runtime to persist the current state of graphs and components so that they are available between restarts. Requires the network:persist capability.
#   #
#   # secret: access token to authorize the user
#
#
#
#   test "Bridge.started",
#   do: assert Bridge.started %Data{}
#
#   # started
#   #
#   # Inform that a given network has been started.
#   #
#   # graph: graph the action targets
#   # time: time when the network was started
#   # running: boolean telling whether the network has live connections
#   # started: boolean telling whether the network has been started. Must be true here
#   # uptime: (optional) time the network has been running, in seconds
#
#
#   test "Bridge.status",
#   do: assert Bridge.status %Data{}
#
#   # status
#   #
#   # Response to a getstatus message.
#   #
#   # graph: graph the action targets
#   # running: boolean telling whether the network has live connections
#   # started: boolean telling whether the network has been started
#   # uptime: (optional) time the network has been running, in seconds
#   # debug: (optional) boolean, tells whether the network is in debug mode
#
#
#
#   test "Bridge.stopped",
#   do: assert Bridge.stopped %Data{}
#
#   # stopped
#   #
#   # Inform that a given network has stopped.
#   #
#   # graph: graph the action targets
#   # time: time when the network was stopped
#   # running: boolean telling whether the network has live connections. Must be false here
#   # started: boolean telling whether the network has been started. May be false or true depending whether the network was stopped by user or just ran to the finish
#   # uptime: (optional) time the network was running, in seconds
#
#
#
#   test "Bridge.debug",
#   do: assert Bridge.debug %Data{}
#
#   # debug
#   #
#   # Set a network into debug mode
#   #
#   # enable: boolean, tells whether to put the network in debug mode
#   # graph: graph the action targets
#   # secret: access token to authorize the user
#
#
#
#
#   test "Bridge.icon",
#   do: assert Bridge.icon %Data{}
#
#   # icon
#   #
#   # Icon of a component instance has changed.
#   #
#   # id: identifier of the node
#   # icon: new icon for the component instance
#   # graph: graph the action targets
#
#
#
#   test "Bridge.output",
#   do: assert Bridge.output %Data{}
#
#   # output
#   #
#   # An output message from a running network, roughly similar to STDOUT output of a Unix process, or a line of console.log in JavaScript. Output can also be used for passing images from the runtime to the UI.
#   #
#   # message: contents of the output line
#   # type: (optional) type of output, either message or previewurl
#   # url: (optional) URL for an image generated by the runtime
#
#
#
#   test "Bridge.error",
#   do: assert Bridge.error %Data{}
#
#   # error
#   #
#   # An error from a running network, roughly similar to STDERR output of a Unix process, or a line of console.error in JavaScript.
#   #
#   # message: contents of the error message
#
#
#
#   test "Bridge.processerror",
#   do: assert Bridge.processerror %Data{}
#
#   # processerror
#   #
#   # When in debug mode, a network can signal an error happening inside a process.
#   #
#   # id: identifier of the node
#   # error: error from the component
#   # graph: graph the action targets
#
#
#
#   test "Bridge.connect",
#   do: assert Bridge.connect %Data{}
#
#   # connect
#   #
#   # Beginning of transmission on an edge.
#   #
#   # id: textual edge identifier, usually in form of a FBP language line
#   # src: source node for the edge
#   # node: node identifier
#   # port: port name
#   # tgt: target node for the edge
#   # node: node identifier
#   # port: port name
#   # graph: graph the action targets
#   # subgraph (optional): subgraph identifier for the event. An array of node IDs
#
#
#   test "Bridge.begingroup",
#   do: assert Bridge.begingroup %Data{}
#
#   # begingroup
#   #
#   # Beginning of a group (bracket IP) on an edge.
#   #
#   # id: textual edge identifier, usually in form of a FBP language line
#   # src: source node for the edge
#   # node: node identifier
#   # port: port name
#   # tgt: target node for the edge
#   # node: node identifier
#   # port: port name
#   # group: group name
#   # graph: graph the action targets
#   # subgraph (optional): subgraph identifier for the event. An array of node IDs
#
#
#
#   test "Bridge.pull",
#   do: assert Bridge.pull %Data{}
#
#   # data
#   #
#   # Data transmission on an edge.
#   #
#   # id: textual edge identifier, usually in form of a FBP language line
#   # src: source node for the edge
#   # node: node identifier
#   # port: port name
#   # tgt: target node for the edge
#   # node: node identifier
#   # port: port name
#   # data: actual data being transmitted, encoded in a way that can be carried over the protocol transport
#   # graph: graph the action targets
#   # subgraph (optional): subgraph identifier for the event. An array of node IDs
#
#
#
#   test "Bridge.endgroup",
#   do: assert Bridge.endgroup %Data{}
#
#   # endgroup
#   #
#   # Ending of a group (bracket IP) on an edge.
#   #
#   # id: textual edge identifier, usually in form of a FBP language line
#   # src: source node for the edge
#   # node: node identifier
#   # port: port name
#   # tgt: target node for the edge
#   # node: node identifier
#   # port: port name
#   # group: group name
#   # graph: graph the action targets
#   # subgraph (optional): subgraph identifier for the event. An array of node IDs
#
#
#
#   test "Bridge.disconnect",
#   do: assert Bridge.disconnect %Data{}
#
#   # disconnect
#   #
#   # End of transmission on an edge.
#   #
#   # id: textual edge identifier, usually in form of a FBP language line
#   # src: source node for the edge
#   # node: node identifier
#   # port: port name
#   # tgt: target node for the edge
#   # node: node identifier
#   # port: port name
#   # graph: graph the action targets
#   # subgraph (optional): subgraph identifier for the event. An array of node IDs
#   # edges
#   #
#   # List of edges user has selected for Loggerion in a user interface or debugger, sent from UI to a runtime.
#
#
#
#   test "Bridge.edges",
#   do: assert Bridge.edges %Data{}
#
#   # edges: list of selected edges, each containing
#   # src: source node for the edge
#   # node: node identifier
#   # port: port name
#   # tgt: target node for the edge
#   # node: node identifier
#   # port: port name
#   # graph: graph the action targets
#   # secret: access token to authorize the user



end